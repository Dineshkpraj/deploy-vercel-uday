# -*- coding: utf-8 -*-
"""Python Chatbot Serverless Function (api/chat.py)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wStdxRrTRzHm3bwUn3LlPT8Dc2BVOGZi
"""

# api/chat.py
# This file contains the Python backend logic adapted for a Vercel serverless function.

import json
import random
import nltk
from nltk.sentiment.vader import SentimentIntensityAnalyzer
from nltk.tokenize import word_tokenize

# --- One-time NLTK Data Setup ---
# This block ensures the necessary NLTK data is downloaded.
# In a serverless environment, this will run on cold starts.
try:
    nltk.data.find('corpora/punkt')
    nltk.data.find('sentiment/vader_lexicon.zip')
    nltk.data.find('corpora/wordnet')
except nltk.downloader.DownloadError:
    print("NLTK data not found. Downloading...")
    nltk.download('punkt')
    nltk.download('vader_lexicon')
    nltk.download('wordnet')
# --- End NLTK Setup ---


class Recommender:
    """
    An advanced recommendation engine using NLTK to understand user intent
    and sentiment.
    """
    def __init__(self):
        self.sentiment_analyzer = SentimentIntensityAnalyzer()
        self.intent_keywords = {
            "stress": {"stress", "pressure", "overwhelmed", "anxious", "worried"},
            "sleep": {"sleep", "tired", "awake", "insomnia", "night"},
            "focus": {"focus", "concentrate", "procrastinating", "distracted"}
        }
        self.recommendations = {
            "stress": [
                "It sounds like you're under pressure. How about trying a 5-minute guided breathing exercise? Just focus on your breath, in and out.",
                "When things feel stressful, a quick walk can make a big difference, even if it's just for a few minutes.",
                "Let's try the 5-4-3-2-1 grounding technique. Name 5 things you can see, 4 you can touch, 3 you can hear, 2 you can smell, and 1 you can taste."
            ],
            "sleep": [
                "If you're having trouble sleeping, it might help to avoid screens for an hour before bed. The blue light can make it harder to fall asleep.",
                "A consistent sleep schedule, even on weekends, can really improve your sleep quality.",
                "Have you tried listening to some calming music or a podcast before bed?"
            ],
            "focus": [
                "For focus, the Pomodoro Technique is great. Work for 25 minutes, then take a 5-minute break. It helps maintain energy.",
                "Make sure your workspace is tidy. A clean space can lead to a clearer mind."
            ],
            "general_negative": [
                "I'm sorry to hear you're feeling that way. Remember that it's okay to not be okay. Talking about it is a great first step.",
                "It sounds like things are tough right now. Please be gentle with yourself."
            ]
        }

    def analyze_and_recommend(self, user_input):
        sentiment_score = self.sentiment_analyzer.polarity_scores(user_input)['compound']
        tokens = word_tokenize(user_input.lower())
        detected_intent = None

        for intent, keywords in self.intent_keywords.items():
            if any(word in tokens for word in keywords):
                detected_intent = intent
                break

        if detected_intent:
            return random.choice(self.recommendations[detected_intent])
        elif sentiment_score < -0.2:
            return random.choice(self.recommendations["general_negative"])

        return None


class CrisisManager:
    """
    Identifies crisis-related keywords and provides an immediate, safe response.
    """
    def __init__(self):
        self.crisis_keywords = [
            "suicide", "kill myself", "want to die", "end my life",
            "self harm", "hurt myself", "cutting", "no reason to live"
        ]
        self.crisis_response = (
            "It sounds like you are in serious distress. It's vital that you speak to someone who can provide immediate support. "
            "Please reach out right now. Here are some 24/7 free and confidential resources:\n"
            "- KIRAN Mental Health Helpline: 1800-599-0019\n"
            "- iCALL Psychosocial Helpline: 022-25521111\n"
            "Your safety is the most important thing. Please make the call."
        )

    def check_for_crisis(self, user_input):
        for keyword in self.crisis_keywords:
            if keyword in user_input.lower():
                return self.crisis_response
        return None


class Chatbot:
    """
    Handles the primary conversational logic of the AI agent.
    """
    def __init__(self):
        self.recommender = Recommender()
        self.rules = {
            "hello": ["Hello there! How are you feeling today?", "Hi! It's good to hear from you. What's on your mind?"],
            "sad": ["I'm sorry to hear you're feeling sad. It's okay to feel that way. Do you want to talk about it?", "It sounds tough. Remember to be kind to yourself. Sometimes just acknowledging the feeling helps."],
            "happy": ["That's wonderful to hear! What's making you feel happy?", "I'm so glad you're feeling happy! Hold on to that feeling."],
            "default": ["Tell me more.", "I'm listening.", "Thanks for sharing that with me. How does that make you feel?", "I see. Could you elaborate on that?"]
        }

    def get_greeting(self):
        """Returns a welcome message."""
        return "Hello! I'm UDAY, your AI companion for mental wellness. You can talk to me about anything on your mind. If you'd like to do a guided check-in, just type 'screening'. To exit, type 'quit'."

    def get_response(self, user_input):
        """
        Generates a response based on user input.
        """
        lower_input = user_input.lower()

        # Check for direct keyword matches first (like "hello", "sad")
        for keyword, responses in self.rules.items():
            if keyword in lower_input:
                # Avoid "sad" matching when a specific recommendation is needed (e.g., "sad because of stress")
                if keyword in ["sad", "happy"] and any(k in lower_input for k_set in self.recommender.intent_keywords.values() for k in k_set):
                    continue
                return random.choice(responses)

        # Then checks for recommendations based on sentiment and intent
        recommendation = self.recommender.analyze_and_recommend(user_input)
        if recommendation:
            return recommendation

        # Finally, falls back to a default response
        return random.choice(self.rules["default"])

# Initialize global instances of the chatbot components
# These will be initialized once per cold start of the serverless function
bot = Chatbot()
crisis_manager = CrisisManager()

# The main handler function for Vercel serverless functions
def handler(request, response):
    """
    Handles incoming HTTP requests for the chatbot.
    """
    if request.method == 'POST':
        try:
            # Parse the JSON body from the request
            body = json.loads(request.body)
            user_input = body.get('message', '').strip()

            bot_response = ""

            # Check for crisis keywords first
            crisis_response = crisis_manager.check_for_crisis(user_input)
            if crisis_response:
                bot_response = crisis_response
            elif user_input.lower() in ["quit", "exit", "bye"]:
                bot_response = "Take care. Remember, I'm here if you need to talk."
            elif "screening" in user_input.lower() or "check-in" in user_input.lower():
                # Screening is a multi-turn conversation, which is harder for a stateless API.
                # For simplicity, we'll return a message indicating the user should start screening
                # and handle the screening logic entirely on the frontend for this version.
                bot_response = "To start the screening, please use the 'screening' command on the frontend. This backend cannot manage multi-turn screening directly."
            else:
                # Get general chatbot response
                bot_response = bot.get_response(user_input)

            # Set the response headers and body
            response.status = 200
            response.headers['Content-Type'] = 'application/json'
            response.headers['Access-Control-Allow-Origin'] = '*' # Allow requests from any origin (for development)
            response.headers['Access-Control-Allow-Methods'] = 'POST, OPTIONS'
            response.headers['Access-Control-Allow-Headers'] = 'Content-Type'
            response.send(json.dumps({'response': bot_response}))

        except json.JSONDecodeError:
            response.status = 400
            response.headers['Content-Type'] = 'application/json'
            response.send(json.dumps({'error': 'Invalid JSON in request body.'}))
        except Exception as e:
            response.status = 500
            response.headers['Content-Type'] = 'application/json'
            response.send(json.dumps({'error': f'An internal server error occurred: {str(e)}'}))
    elif request.method == 'OPTIONS':
        # Handle CORS preflight requests
        response.status = 204
        response.headers['Access-Control-Allow-Origin'] = '*'
        response.headers['Access-Control-Allow-Methods'] = 'POST, OPTIONS'
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type'
        response.send('')
    else:
        response.status = 405
        response.headers['Content-Type'] = 'application/json'
        response.send(json.dumps({'error': 'Method Not Allowed'}))